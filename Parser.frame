/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University
ported to Typescript by Stefan Kempinger, Univ. of Linz

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin
import {Trace} from "./Trace";
import {Graph, Node_, Position, Symbol, SymInfo, Tab} from "./Tab";
import {ParserGen} from "./ParserGen";
import {CharSet, DFA} from "./DFA";
import {Scanner, Token} from "./Scanner";

export class Parser  {
-->constants
	static _T = true;
    static _x = false;
    static minErrDist = 2;

    public t: Token;            // last recognized token
    public la: Token;           // lookahead token
    errDist = Parser.minErrDist;

    public scanner: Scanner;
    public errors: Errors;

	-->declarations

	constructor(scanner: Scanner) {
        this.scanner = scanner;
        this.errors = new Errors();
    }

    SynErr(n: number) {
        if (this.errDist >= Parser.minErrDist) this.errors.SynErr(this.la.line, this.la.col, n);
        this.errDist = 0;
    }

    public SemErr(msg: string) {
        if (this.errDist >= Parser.minErrDist) this.errors.SemErr(this.t.line, this.t.col, msg);
        this.errDist = 0;
    }

	Get() {
        for (; ;) {
            this.t = this.la;
            this.la = this.scanner.Scan();
            if (this.la.kind <= Parser.maxT) {
                ++this.errDist;
                break;
            }
-->pragmas
			this.la = this.t;
        }
    }

    private isLaTokenKindEqualTo(n:number):boolean{
        return this.la.kind == n;
    }

    Expect(n: number) {
        if (this.la.kind == n)
            this.Get();
        else {
            this.SynErr(n);
        }
    }

    StartOf(s: number): boolean {
        return Parser.set[s][this.la.kind];
    }

    ExpectWeak(n: number, follow: number) {
        if (this.la.kind == n) this.Get();
        else {
            this.SynErr(n);
            while (!this.StartOf(follow)) this.Get();
        }
    }

    WeakSeparator(n: number, syFol: number, repFol: number): boolean {
        let kind = this.la.kind;
        if (kind == n) {
            this.Get();
            return true;
        } else if (this.StartOf(repFol)) return false;
        else {
            this.SynErr(n);
            while (!(Parser.set[syFol][kind] || Parser.set[repFol][kind] || Parser.set[0][kind])) {
                this.Get();
                kind = this.la.kind;
            }
            return this.StartOf(syFol);
        }
    }

-->productions

    public Parse() {
        this.la = new Token();
        this.la.val = "";
        this.Get();
-->parseRoot
	}

    static set:boolean[][] = [
-->initialization
	];
} // end Parser



export class Errors {
    public count = 0;                                    // number of errors detected
    //public errorStream = System.out;     // error messages go to this stream
    public errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

    protected printMsg(line: number, column: number, msg: string) {
        let b = "-- line {0} col {1}: {2}";
        let pos = b.indexOf("{0}");
        if (pos >= 0) {
            b = b.replace("{0}", line + "")
        }
        pos = b.indexOf("{1}");
        if (pos >= 0) {
            b = b.replace("{1}", column + "")
        }
        pos = b.indexOf("{2}");
        if (pos >= 0)
            b = b.replace("{2}", msg)
        console.error(b.toString());
    }

    public SynErr(line: number, col: number, n: number) {
        let s: string;
        switch (n) { -->errors
            default:
                s = "error " + n;
                break;
        }
        this.printMsg(line, col, s);
        this.count++;
    }

    public SemErr(s: string)
    public SemErr(line: number, col: number, s: string)
    //internal useage
    public SemErr(line: any, col?: number, s?: string) {
        if (s != undefined)
            this.printMsg(line, col, s);
        else
            console.error(line);
        this.count++;
    }


    public Warning(s: string)
    public Warning(line: number, col: number, s: string)
    //internal useage
    public Warning(line: any, col?: number, s?: string) {
        if (s != undefined)
            this.printMsg(line, col, s);
        else
            console.warn(line);
    }

} // Errors

