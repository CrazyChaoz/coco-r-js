/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import {Trace} from "./Trace";
import {Graph, Node_, Position, SymInfo, Tab, Symbol} from "./Tab";
import {ParserGen} from "./ParserGen";
import {CharSet, DFA} from "./DFA";
import {Scanner, Token} from "./Scanner";

public export class Parser {
    public static   _EOF = 0;
    public static   _ident = 1;
    public static   _number = 2;
    public static   _string = 3;
    public static   _badString = 4;
    public static   _char = 5;
    public static   maxT = 44;
    public static   _ddtSym = 45;
    public static   _optionSym = 46;

    static   _T = true;
    static   _x = false;
    static   minErrDist = 2;

    public  t:Token;    // last recognized token
    public  la:Token;   // lookahead token
    errDist = Parser.minErrDist;

    public  scanner:Scanner;
    public  errors:Errors;

    static   id = 0;
    static   str = 1;

    public  trace:Trace;         // other Coco objects referenced by this ATG
    public  tab:Tab;
    public  dfa:DFA;
    public  pgen:ParserGen;

     genScanner:boolean;
     tokenString:string;         // used in declarations of literal tokens
     noString = "-none-"; // used in declarations of literal tokens

    /*-------------------------------------------------------------------------*/



    constructor( scanner:Scanner) {
    this.scanner = scanner;
    this.errors = new Errors();
}

 SynErr ( n:number) {
    if (this.errDist >= Parser.minErrDist) this.errors.SynErr(this.la.line, this.la.col, n);
    this.errDist = 0;
}

public  SemErr ( msg:string) {
    if (this.errDist >= Parser.minErrDist) this.errors.SemErr(this.t.line, this.t.col, msg);
    this.errDist = 0;
}

 Get () {
    for (;;) {
        this.t = this.la;
        this.la = this.scanner.Scan();
        if (this.la.kind <= Parser.maxT) {
            ++this.errDist;
            break;
        }

        if (this.la.kind == 45) {
            this.tab.SetDDT(this.la.val);
        }
        if (this.la.kind == 46) {
            this.tab.SetOption(this.la.val);
        }
        this.la = this.t;
    }
}

 Expect ( n:number) {
    if (this.la.kind==n) this.Get(); else { this.SynErr(n); }
}

 StartOf ( s:number) :boolean{
    return Parser.set[s][this.la.kind];
}

 ExpectWeak ( n:number,  follow:number) {
    if (this.la.kind == n) this.Get();
    else {
        this.SynErr(n);
        while (!this.StartOf(follow)) this.Get();
    }
}

 WeakSeparator ( n:number,  syFol:number,  repFol:number):boolean {
    let kind = this.la.kind;
    if (kind == n) { this.Get(); return true; }
    else if (this.StartOf(repFol)) return false;
    else {
        this.SynErr(n);
        while (!(Parser.set[syFol][kind] || Parser.set[repFol][kind] || Parser.set[0][kind])) {
            this.Get();
            kind = this.la.kind;
        }
        return this.StartOf(syFol);
    }
}

 Coco() {
    let sym:Symbol;
    let g, g1, g2:Graph; let gramName:string;  let s:CharSet; let beg:number;
    if (this.StartOf(1)) {
        this.Get();
        beg = this.t.pos;
        while (this.StartOf(1)) {
            this.Get();
        }
        this.pgen.usingPos = new Position(beg, this.la.pos, 0);
    }
    this.Expect(6);
     this.genScanner = true;
    this.tab.ignored = new CharSet();
     this.Expect(1);
    gramName = this.t.val;
    beg = this.la.pos;

    while (this.StartOf(2)) {
        this.Get();
    }
    this.tab.semDeclPos = new Position(beg, this.la.pos, 0);
    if (this.la.kind == 7) {
        this.Get();
        this.dfa.ignoreCase = true;
    }
    if (this.la.kind == 8) {
        this.Get();
        // @ts-ignore
        while (this.la.kind == 1) {
            this.SetDecl();
        }
    }
    if (this.la.kind == 9) {
        this.Get();
        // @ts-ignore
        while (this.la.kind == 1 || this.la.kind == 3 || this.la.kind == 5) {
            this.TokenDecl(Node_.t);
        }
    }
    if (this.la.kind == 10) {
        this.Get();
        // @ts-ignore
        while (this.la.kind == 1 || this.la.kind == 3 || this.la.kind == 5) {
            this.TokenDecl(Node_.pr);
        }
    }
    while (this.la.kind == 11) {
        this.Get();
        let nested = false;
        this.Expect(12);
        g1 = this.TokenExpr();
        this.Expect(13);
        g2 = this.TokenExpr();
        if (this.la.kind == 14) {
            this.Get();
            nested = true;
        }
        this.dfa.NewComment(g1.l, g2.l, nested);
    }
    while (this.la.kind == 15) {
        this.Get();
        s = this.Set();
        this.tab.ignored.Or(s);
    }
    while (!(this.la.kind == 0 || this.la.kind == 16)) {this.SynErr(45); this.Get();}
    this.Expect(16);
    if (this.genScanner) this.dfa.MakeDeterministic();
    this.tab.DeleteNodes();

    // @ts-ignore
     while (this.la.kind == 1) {
        this.Get();
        sym = this.tab.FindSym(this.t.val);
        let undef = sym == null;
        if (undef) sym = this.tab.NewSym(Node_.nt, this.t.val, this.t.line);
        else {
            if (sym.typ == Node_.nt) {
                if (sym.graph != null) this.SemErr("name declared twice");
            } else this.SemErr("this symbol kind not allowed on left side of production");
            sym.line = this.t.line;
        }
        let noAttrs = sym.attrPos == null;
        sym.attrPos = null;
        let noRet = sym.retVar==null;
        sym.retVar = null;

        if (this.la.kind == 24 || this.la.kind == 29) {
            this.AttrDecl(sym);
        }
        if (!undef)
            if (noAttrs != (sym.attrPos == null)
                || noRet != (sym.retVar == null))
                this.SemErr("attribute mismatch between declaration and use of this symbol");

        if (this.la.kind == 42) {
            sym.semPos = this.SemText();
        }
         this.ExpectWeak(17, 3);
        g = this.Expression();
        sym.graph = g.l;
        this.tab.Finish(g);

        this.ExpectWeak(18, 4);
    }
    this.Expect(19);
    this.Expect(1);
    if (gramName!=this.t.val)
        this.SemErr("name does not match grammar name");
    this.tab.gramSy = this.tab.FindSym(gramName);
    if (this.tab.gramSy == null)
        this.SemErr("missing production for grammar name");
    else {
        sym = this.tab.gramSy;
        if (sym.attrPos != null)
            this.SemErr("grammar symbol must not have attributes");
    }
    this.tab.noSym = this.tab.NewSym(Node_.t, "???", 0); // noSym gets highest number
    this.tab.SetupAnys();
    this.tab.RenumberPragmas();
    if (this.tab.ddt[2]) this.tab.PrintNodes();
    if (this.errors.count == 0) {
        console.log("checking");
        this.tab.CompSymbolSets();
        if (this.tab.ddt[7]) this.tab.XRef();
        if (this.tab.GrammarOk()) {
            console.log("parser");
            this.pgen.WriteParser();
            if (this.genScanner) {
                console.log(" + scanner");
                this.dfa.WriteScanner();
                if (this.tab.ddt[0]) this.dfa.PrintStates();
            }
            console.log(" generated");
            if (this.tab.ddt[8]) this.pgen.WriteStatistics();
        }
    }
    if (this.tab.ddt[6]) this.tab.PrintSymbolTable();

    this.Expect(18);
}

 SetDecl() {
    let s:CharSet;
    this.Expect(1);
    let name = this.t.val;
    let c = this.tab.FindCharClass(name);
    if (c != null) this.SemErr("name declared twice");

    this.Expect(17);
    s = this.Set();
    if (s.Elements() == 0) this.SemErr("character set must not be empty");
    c = this.tab.NewCharClass(name, s);

    this.Expect(18);
}

 TokenDecl( typ:number) {
    let s:SymInfo; let sym:Symbol; let g:Graph;
    s = this.Sym();
    sym = this.tab.FindSym(s.name);
    if (sym != null) this.SemErr("name declared twice");
    else {
        sym = this.tab.NewSym(typ, s.name, t.line);
        sym.tokenKind = Symbol.fixedToken;
    }
    this.tokenString = null;

    while (!(this.StartOf(5))) {this.SynErr(46); this.Get();}
    if (this.la.kind == 17) {
        this.Get();
        g = this.TokenExpr();
        this.Expect(18);
        if (s.kind == Parser.str) this.SemErr("a literal must not be declared with a structure");
        this.tab.Finish(g);
        if (this.tokenString == null || this.tokenString===this.noString)
            this.dfa.ConvertToStates(g.l, sym);
        else { // TokenExpr is a single string
            if (this.tab.literals.get(this.tokenString) != null)
                this.SemErr("token string declared twice");
            this.tab.literals.put(tokenString, sym);
            this.dfa.MatchLiteral(this.tokenString, sym);
        }

    } else if (this.StartOf(6)) {
        if (s.kind == Parser.id) this.genScanner = false;
        else this.dfa.MatchLiteral(sym.name, sym);

    } else this.SynErr(47);
    if (this.la.kind == 42) {
        sym.semPos = this.SemText();
        if (typ != Node_.pr) this.SemErr("semantic action not allowed here");
    }
}

  TokenExpr() :Graph{
    let  g:Graph;
    let g2:Graph;
    g = this.TokenTerm();
    let first = true;
    while (this.WeakSeparator(33,7,8) ) {
        g2 = this.TokenTerm();
        if (first) { this.tab.MakeFirstAlt(g); first = false; }
        this.tab.MakeAlternative(g, g2);

    }
    return g;
}

  Set():CharSet {
    let  s:CharSet;
    let s2:CharSet;
    s = this.SimSet();
    while (this.la.kind == 20 || this.la.kind == 21) {
        if (this.la.kind == 20) {
            this.Get();
            s2 = this.SimSet();
            s.Or(s2);
        } else {
            this.Get();
            s2 = this.SimSet();
            s.Subtract(s2);
        }
    }
    return s;
}

 AttrDecl( sym:Symbol) {
    let beg, col:number;
    if (this.la.kind == 24) {
        this.Get();
        // @ts-ignore
        if (this.la.kind == 25 || this.la.kind == 26) {
            if (this.la.kind == 25) {
                this.Get();
            } else {
                this.Get();
            }
            beg = this.la.pos;
            this.TypeName();
            sym.retType = this.scanner.buffer.GetString(beg, this.la.pos);
            this.Expect(1);
            sym.retVar = this.t.val;
            if (this.la.kind == 27) {
                this.Get();
            } else if (this.la.kind == 28) {
                this.Get();
                beg = this.la.pos; col = this.la.col;
                while (this.StartOf(9)) {
                    this.Get();
                }
                this.Expect(27);
                if (this.t.pos > beg)
                    sym.attrPos = new Position(beg, this.t.pos, col);
            } else this.SynErr(48);
        } else if (this.StartOf(10)) {
            beg = this.la.pos; col = this.la.col;
            if (this.StartOf(11)) {
                this.Get();
                while (this.StartOf(9)) {
                    this.Get();
                }
            }
            this.Expect(27);
            if (this.t.pos > beg)
                sym.attrPos = new Position(beg, this.t.pos, col);
        } else this.SynErr(49);
    } else if (this.la.kind == 29) {
        this.Get();
        // @ts-ignore
        if (this.la.kind == 25 || this.la.kind == 26) {
            if (this.la.kind == 25) {
                this.Get();
            } else {
                this.Get();
            }
            beg = this.la.pos;
            this.TypeName();
            sym.retType = this.scanner.buffer.GetString(beg, this.la.pos);
            this.Expect(1);
            sym.retVar = this.t.val;
            if (this.la.kind == 30) {
                this.Get();
            } else if (this.la.kind == 28) {
                this.Get();
                beg = this.la.pos; col = this.la.col;
                while (this.StartOf(12)) {
                    this.Get();
                }
                this.Expect(30);
                if (this.t.pos > beg)
                    sym.attrPos = new Position(beg, this.t.pos, col);
            } else this.SynErr(50);
        } else if (this.StartOf(10)) {
            beg = this.la.pos; col = this.la.col;
            if (this.StartOf(13)) {
                this.Get();
                while (this.StartOf(12)) {
                    this.Get();
                }
            }
            this.Expect(30);
            if (this.t.pos > beg)
                sym.attrPos = new Position(beg, this.t.pos, col);
        } else this.SynErr(51);
    } else this.SynErr(52);
}

  SemText() :Position{
    let  pos:Position;
    this.Expect(42);
    let beg = this.la.pos; let col = this.la.col;
    while (this.StartOf(14)) {
        if (this.StartOf(15)) {
            this.Get();
        } else if (this.la.kind == 4) {
            this.Get();
            this.SemErr("bad string in semantic action");
        } else {
            this.Get();
            this.SemErr("missing end of previous semantic action");
        }
    }
      this.Expect(43);
    pos = new Position(beg, this.t.pos, col);
    return pos;
}

  Expression() :Graph{
    let  g:Graph;
    let g2:Graph;
    g = this.Term();
    let first = true;
    while (this.WeakSeparator(33,16,17) ) {
        g2 = this.Term();
        if (first) { this.tab.MakeFirstAlt(g); first = false; }
        this.tab.MakeAlternative(g, g2);

    }
    return g;
}

  SimSet() :CharSet{
    let  s:CharSet;
    let n1, n2:number;
    s = new CharSet();
    if (this.la.kind == 1) {
        this.Get();
        let c = this.tab.FindCharClass(this.t.val);
        if (c == null) this.SemErr("undefined name"); else s.Or(c.set);

    } else if (this.la.kind == 3) {
        this.Get();
        let name = this.t.val;
        name = this.tab.Unescape(name.substring(1, name.length-1));
        for (let i = 0; i < name.length; i++)
        if (this.dfa.ignoreCase) s.Set(Character.toLowerCase(name.charAt(i)));
        else s.Set(name.charAt(i));
    } else if (this.la.kind == 5) {
        n1 = this.Char();
        s.Set(n1);
        // @ts-ignore
        if (this.la.kind == 22) {
            this.Get();
            n2 = this.Char();
            for (let i = n1; i <= n2; i++) s.Set(i);
        }
    } else if (this.la.kind == 23) {
        this.Get();
        s = new CharSet(); s.Fill();
    } else this.SynErr(53);
    return s;
}

  Char():number {
    let  n:number;
    this.Expect(5);
    let name = this.t.val; n = 0;
    name = this.tab.Unescape(name.substring(1, name.length-1));
    if (name.length == 1) n = name.charAt(0).charCodeAt(0);
    else this.SemErr("unacceptable character value");
    if (this.dfa.ignoreCase && n >= 'A'.charCodeAt(0) && n <= 'Z'.charCodeAt(0)) n += 32;

    return n;
}

  Sym() :SymInfo{
    let  s:SymInfo;
    s = new SymInfo(); s.name = "???"; s.kind = Parser.id;
    if (this.la.kind == 1) {
        this.Get();
        s.kind = Parser.id; s.name = this.t.val;
    } else if (this.la.kind == 3 || this.la.kind == 5) {
        if (this.la.kind == 3) {
            this.Get();
            s.name = this.t.val;
        } else {
            this.Get();
            s.name = "\"" + this.t.val.substring(1, this.t.val.length-1) + "\"";
        }
        s.kind = Parser.str;
        if (this.dfa.ignoreCase) s.name = s.name.toLowerCase();
        if (s.name.indexOf(' ') >= 0)
            this.SemErr("literal tokens must not contain blanks");
    } else this.SynErr(54);
    return s;
}

 TypeName() {
    this.Expect(1);
    while (this.la.kind == 18 || this.la.kind == 24 || this.la.kind == 31) {
        if (this.la.kind == 18) {
            this.Get();
            this.Expect(1);
        } else if (la.kind == 31) {
            Get();
            Expect(32);
        } else {
            Get();
            TypeName();
            while (la.kind == 28) {
                Get();
                TypeName();
            }
            Expect(27);
        }
    }
}

  Term():Graph {
    Graph  g;
    Graph g2; Node rslv = null; g = null;
    if (StartOf(18)) {
        if (la.kind == 40) {
            rslv = tab.NewNode(Node.rslv, null, la.line);
            rslv.pos = Resolver();
            g = new Graph(rslv);
        }
        g2 = Factor();
        if (rslv != null) tab.MakeSequence(g, g2);
        else g = g2;

        while (StartOf(19)) {
            g2 = Factor();
            tab.MakeSequence(g, g2);
        }
    } else if (StartOf(20)) {
        g = new Graph(tab.NewNode(Node.eps, null, 0));
    } else SynErr(55);
    if (g == null) // invalid start of Term
        g = new Graph(tab.NewNode(Node.eps, null, 0));

    return g;
}

  Resolver() :Position{
    Position  pos;
    Expect(40);
    Expect(35);
    int beg = la.pos; int col = la.col;
    Condition();
    pos = new Position(beg, t.pos, col);
    return pos;
}

  Factor():Graph {
    Graph  g;
    SymInfo s; Position pos; boolean weak = false;
    g = null;
    switch (la.kind) {
        case 1: case 3: case 5: case 34: {
            if (la.kind == 34) {
                Get();
                weak = true;
            }
            s = Sym();
            let sym = tab.FindSym(s.name);
            if (sym == null && s.kind == str)
                sym = tab.literals.get(s.name);
            boolean undef = sym == null;
            if (undef) {
                if (s.kind == id)
                    sym = tab.NewSym(Node.nt, s.name, 0);  // forward nt
                else if (genScanner) {
                    sym = tab.NewSym(Node.t, s.name, t.line);
                    dfa.MatchLiteral(sym.name, sym);
                } else {  // undefined string in production
                    SemErr("undefined string in production");
                    sym = tab.eofSy;  // dummy
                }
            }
            int typ = sym.typ;
            if (typ != Node.t && typ != Node.nt)
                SemErr("this symbol kind is not allowed in a production");
            if (weak)
                if (typ == Node.t) typ = Node.wt;
                else SemErr("only terminals may be weak");
            let p = tab.NewNode(typ, sym, t.line);
            g = new Graph(p);

            if (la.kind == 24 || la.kind == 29) {
                Attribs(p);
                if (s.kind != id) SemErr("a literal must not have attributes");
            }
            if (undef) {
                sym.attrPos = p.pos;  // dummy
                sym.retVar = p.retVar;  // AH - dummy
            } else if ((p.pos == null) != (sym.attrPos == null)
                || (p.retVar == null) != (sym.retVar == null))
                SemErr("attribute mismatch between declaration and use of this symbol");

            break;
        }
        case 35: {
            Get();
            g = Expression();
            Expect(36);
            break;
        }
        case 31: {
            Get();
            g = Expression();
            Expect(32);
            tab.MakeOption(g);
            break;
        }
        case 37: {
            Get();
            g = Expression();
            Expect(38);
            tab.MakeIteration(g);
            break;
        }
        case 42: {
            pos = SemText();
            let p = tab.NewNode(Node_.sem, null, 0);
            p.pos = pos;
            g = new Graph(p);

            break;
        }
        case 23: {
            Get();
            let p = tab.NewNode(Node_.any, null, t.line);  // p.set is set in tab.SetupAnys
            g = new Graph(p);

            break;
        }
        case 39: {
            Get();
            let p = tab.NewNode(Node_.sync, null, 0);
            g = new Graph(p);

            break;
        }
        default: SynErr(56); break;
    }
    if (g == null) // invalid start of Factor
        g = new Graph(tab.NewNode(Node_.eps, null, 0));

    return g;
}

 Attribs( n:Node_) {
    int beg, col;
    if (la.kind == 24) {
        Get();
        if (la.kind == 25 || la.kind == 26) {
            if (la.kind == 25) {
                Get();
            } else {
                Get();
            }
            beg = la.pos;
            while (StartOf(21)) {
                if (StartOf(22)) {
                    Get();
                } else if (la.kind == 31 || la.kind == 35) {
                    Bracketed();
                } else {
                    Get();
                    SemErr("bad string in attributes");
                }
            }
            n.retVar = scanner.buffer.GetString(beg, la.pos);
            if (la.kind == 27) {
                Get();
            } else if (la.kind == 28) {
                Get();
                beg = la.pos; col = la.col;
                while (StartOf(9)) {
                    if (StartOf(23)) {
                        Get();
                    } else {
                        Get();
                        SemErr("bad string in attributes");
                    }
                }
                Expect(27);
                if (t.pos > beg) n.pos = new Position(beg, t.pos, col);
            } else SynErr(57);
        } else if (StartOf(10)) {
            beg = la.pos; col = la.col;
            if (StartOf(11)) {
                if (StartOf(24)) {
                    Get();
                } else {
                    Get();
                    SemErr("bad string in attributes");
                }
                while (StartOf(9)) {
                    if (StartOf(23)) {
                        Get();
                    } else {
                        Get();
                        SemErr("bad string in attributes");
                    }
                }
            }
            Expect(27);
            if (t.pos > beg) n.pos = new Position(beg, t.pos, col);
        } else SynErr(58);
    } else if (la.kind == 29) {
        Get();
        if (la.kind == 25 || la.kind == 26) {
            if (la.kind == 25) {
                Get();
            } else {
                Get();
            }
            beg = la.pos;
            while (StartOf(25)) {
                if (StartOf(26)) {
                    Get();
                } else if (la.kind == 31 || la.kind == 35) {
                    Bracketed();
                } else {
                    Get();
                    SemErr("bad string in attributes");
                }
            }
            n.retVar = scanner.buffer.GetString(beg, la.pos);
            if (la.kind == 30) {
                Get();
            } else if (la.kind == 28) {
                Get();
                beg = la.pos; col = la.col;
                while (StartOf(12)) {
                    if (StartOf(27)) {
                        Get();
                    } else {
                        Get();
                        SemErr("bad string in attributes");
                    }
                }
                Expect(30);
                if (t.pos > beg) n.pos = new Position(beg, t.pos, col);
            } else SynErr(59);
        } else if (StartOf(10)) {
            beg = la.pos; col = la.col;
            if (StartOf(13)) {
                if (StartOf(28)) {
                    Get();
                } else {
                    Get();
                    SemErr("bad string in attributes");
                }
                while (StartOf(12)) {
                    if (StartOf(27)) {
                        Get();
                    } else {
                        Get();
                        SemErr("bad string in attributes");
                    }
                }
            }
            Expect(30);
            if (t.pos > beg) n.pos = new Position(beg, t.pos, col);
        } else SynErr(60);
    } else SynErr(61);
}

 Condition() {
    while (StartOf(29)) {
        if (la.kind == 35) {
            Get();
            Condition();
        } else {
            Get();
        }
    }
    Expect(36);
}

  TokenTerm():Graph {
    Graph  g;
    Graph g2;
    g = TokenFactor();
    while (StartOf(7)) {
        g2 = TokenFactor();
        tab.MakeSequence(g, g2);
    }
    if (la.kind == 41) {
        Get();
        Expect(35);
        g2 = TokenExpr();
        tab.SetContextTrans(g2.l); dfa.hasCtxMoves = true;
        tab.MakeSequence(g, g2);
        Expect(36);
    }
    return g;
}

  TokenFactor():Graph {
    Graph  g;
    SymInfo s;
    g = null;
    if (la.kind == 1 || la.kind == 3 || la.kind == 5) {
        s = Sym();
        if (s.kind == id) {
            CharClass c = tab.FindCharClass(s.name);
            if (c == null) {
                SemErr("undefined name");
                c = tab.NewCharClass(s.name, new CharSet());
            }
            Node p = tab.NewNode(Node.clas, null, 0); p.val = c.n;
            g = new Graph(p);
            tokenString = noString;
        } else { // str
            g = tab.StrToGraph(s.name);
            if (tokenString == null) tokenString = s.name;
            else tokenString = noString;
        }

    } else if (la.kind == 35) {
        Get();
        g = TokenExpr();
        Expect(36);
    } else if (la.kind == 31) {
        Get();
        g = TokenExpr();
        Expect(32);
        tab.MakeOption(g); tokenString = noString;
    } else if (la.kind == 37) {
        Get();
        g = TokenExpr();
        Expect(38);
        tab.MakeIteration(g); tokenString = noString;
    } else SynErr(62);
    if (g == null) // invalid start of TokenFactor
        g = new Graph(tab.NewNode(Node.eps, null, 0));
    return g;
}

Bracketed() {
    if (la.kind == 35) {
        Get();
        while (StartOf(29)) {
            if (la.kind == 31 || la.kind == 35) {
                Bracketed();
            } else {
                Get();
            }
        }
        Expect(36);
    } else if (la.kind == 31) {
        Get();
        while (StartOf(30)) {
            if (la.kind == 31 || la.kind == 35) {
                Bracketed();
            } else {
                Get();
            }
        }
        this.Expect(32);
    } else SynErr(63);
}



public Parse() {
    this.la = new Token();
    la.val = "";
    Get();
    Coco();
    Expect(0);

}

static set = [
    [Parser._T,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._T,Parser._T,Parser._T,Parser._x, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._T,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._x,Parser._T, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._T,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._T,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._T,Parser._x,Parser._x,Parser._x, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._x,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._x,Parser._x, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._T,Parser._x,Parser._x,Parser._x, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._T,Parser._x,Parser._T, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._T, Parser._x,Parser._x,Parser._T,Parser._T, Parser._x,Parser._T,Parser._x,Parser._T, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._T,Parser._T,Parser._x,Parser._x, Parser._T,Parser._x,Parser._T,Parser._x, Parser._x,Parser._x,Parser._x,Parser._x, Parser._x,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._x,Parser._T,Parser._T,Parser._x, Parser._T,Parser._T,Parser._T,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._x,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._x,Parser._x, Parser._T,Parser._T,Parser._T,Parser._x, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x,Parser._x,Parser._T, Parser._T,Parser._T,Parser._x,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x],
    [Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._x,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._T,Parser._T,Parser._T, Parser._T,Parser._x]

];
} // end Parser


export class Errors {
    public  count = 0;                                    // number of errors detected
    public errorStream = System.out;     // error messages go to this stream
    public errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

    protected  printMsg( line:number,  column:number,  msg:string) {
    let b = new StringBuffer(this.errMsgFormat);
    let pos = b.indexOf("{0}");
    if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, line); }
pos = b.indexOf("{1}");
if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, column); }
pos = b.indexOf("{2}");
if (pos >= 0) b.replace(pos, pos+3, msg);
this.errorStream.println(b.toString());
}

public SynErr ( line:number,  col:number,  n:number) {
    let s:string;
    switch (n) {
        case 0: s = "EOF expected"; break;
        case 1: s = "ident expected"; break;
        case 2: s = "number expected"; break;
        case 3: s = "string expected"; break;
        case 4: s = "badString expected"; break;
        case 5: s = "char expected"; break;
        case 6: s = "\"COMPILER\" expected"; break;
        case 7: s = "\"IGNORECASE\" expected"; break;
        case 8: s = "\"CHARACTERS\" expected"; break;
        case 9: s = "\"TOKENS\" expected"; break;
        case 10: s = "\"PRAGMAS\" expected"; break;
        case 11: s = "\"COMMENTS\" expected"; break;
        case 12: s = "\"FROM\" expected"; break;
        case 13: s = "\"TO\" expected"; break;
        case 14: s = "\"NESTED\" expected"; break;
        case 15: s = "\"IGNORE\" expected"; break;
        case 16: s = "\"PRODUCTIONS\" expected"; break;
        case 17: s = "\"=\" expected"; break;
        case 18: s = "\".\" expected"; break;
        case 19: s = "\"END\" expected"; break;
        case 20: s = "\"+\" expected"; break;
        case 21: s = "\"-\" expected"; break;
        case 22: s = "\"..\" expected"; break;
        case 23: s = "\"ANY\" expected"; break;
        case 24: s = "\"<\" expected"; break;
        case 25: s = "\"^\" expected"; break;
        case 26: s = "\"out\" expected"; break;
        case 27: s = "\">\" expected"; break;
        case 28: s = "\",\" expected"; break;
        case 29: s = "\"<.\" expected"; break;
        case 30: s = "\".>\" expected"; break;
        case 31: s = "\"[\" expected"; break;
        case 32: s = "\"]\" expected"; break;
        case 33: s = "\"|\" expected"; break;
        case 34: s = "\"WEAK\" expected"; break;
        case 35: s = "\"(\" expected"; break;
        case 36: s = "\")\" expected"; break;
        case 37: s = "\"{\" expected"; break;
        case 38: s = "\"}\" expected"; break;
        case 39: s = "\"SYNC\" expected"; break;
        case 40: s = "\"IF\" expected"; break;
        case 41: s = "\"CONTEXT\" expected"; break;
        case 42: s = "\"(.\" expected"; break;
        case 43: s = "\".)\" expected"; break;
        case 44: s = "??? expected"; break;
        case 45: s = "this symbol not expected in Coco"; break;
        case 46: s = "this symbol not expected in TokenDecl"; break;
        case 47: s = "invalid TokenDecl"; break;
        case 48: s = "invalid AttrDecl"; break;
        case 49: s = "invalid AttrDecl"; break;
        case 50: s = "invalid AttrDecl"; break;
        case 51: s = "invalid AttrDecl"; break;
        case 52: s = "invalid AttrDecl"; break;
        case 53: s = "invalid SimSet"; break;
        case 54: s = "invalid Sym"; break;
        case 55: s = "invalid Term"; break;
        case 56: s = "invalid Factor"; break;
        case 57: s = "invalid Attribs"; break;
        case 58: s = "invalid Attribs"; break;
        case 59: s = "invalid Attribs"; break;
        case 60: s = "invalid Attribs"; break;
        case 61: s = "invalid Attribs"; break;
        case 62: s = "invalid TokenFactor"; break;
        case 63: s = "invalid Bracketed"; break;
        default: s = "error " + n; break;
    }
    this.printMsg(line, col, s);
    this.count++;
}

public  SemErr ( line?:number,  col?:number,  s:string) {
        if (line!=undefined)
            this.printMsg(line, col, s);
        else
            this.errorStream.println(s);
    this.count++;
}


public  Warning ( line?:number,  col?:number,  s:string) {
    if (line!=undefined)
        this.printMsg(line, col, s);
    else
        this.errorStream.println(s);
}

} // Errors

/*
class FatalError extends RuntimeException {
    public static final long serialVersionUID = 1L;
    public FatalError(String s) { super(s); }
}
*/